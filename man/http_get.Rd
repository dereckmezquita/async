% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/http.R
\name{http_get}
\alias{http_get}
\title{Asynchronous HTTP GET request}
\usage{
http_get(
  url,
  headers = character(),
  file = NULL,
  options = list(),
  on_progress = NULL
)
}
\arguments{
\item{url}{URL to connect to.}

\item{headers}{HTTP headers to send.}

\item{file}{If not \code{NULL}, it must be a string, specifying a file.
The body of the response is written to this file.}

\item{options}{Options to set on the handle. Passed to
\code{\link[curl:handle]{curl::handle_setopt()}}.}

\item{on_progress}{Progress handler function. It is only used if the
response body is written to a file. See details below.}
}
\value{
Deferred object.
}
\description{
Start an HTTP GET request in the background, and report its completion
via a deferred.
}
\section{HTTP event emitters}{

An async HTTP deferred object is also an event emitter, see
\link{event_emitter}. Use \verb{$event_emitter} to access the event emitter API,
and call \verb{$event_emitter$listen_on()} etc. to listen on HTTP events,
etc.
\itemize{
\item \code{"data"} is emitted when we receive data from the server, the data is
passed on to the listeners as a raw vector. Note that zero-length
raw vectors might also happen.
\item \code{"end"} is emitted at the end of the HTTP data stream, without
additional arguments (Also on error.)
}

Here is an example, that uses the web server from the webfakes
package:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{http <- webfakes::new_app_process(webfakes::httpbin_app())
stream_http <- function() \{
  query <- http_get(http$url("/drip?duration=3&numbytes=10"))
  query$event_emitter$
    listen_on("data", function(bytes) \{
      writeLines(paste("Got", length(bytes), "byte(s):"))
      print(bytes)
    \})$
    listen_on("end", function() \{
      writeLines("Done.")
    \})
  query
\}

response <- synchronise(stream_http())
}\if{html}{\out{</div>}}
}

\section{Progress bars}{


\code{http_get} can report on the progress of the download, via the
\code{on_progress} argument. This is called with a list, with entries:
\itemize{
\item \code{url}: the specified url to download
\item \code{handle}: the curl handle of the request. This can be queried using
\code{\link[curl:handle]{curl::handle_data()}} to get the response status_code, the final
URL (after redirections), timings, etc.
\item \code{file}: the \code{file} argument.
\item \code{total}: total bytes of the response. If this is unknown, it is set
to zero.
\item \code{current}: already received bytes of the response.
}
}

\examples{
\donttest{
afun <- async(function() {
  http_get("https://eu.httpbin.org/status/200")$
    then(function(x) x$status_code)
})
synchronise(afun())
}
}
\seealso{
Other asyncronous HTTP calls: 
\code{\link{http_head}()},
\code{\link{http_setopt}()}
}
\concept{asyncronous HTTP calls}
